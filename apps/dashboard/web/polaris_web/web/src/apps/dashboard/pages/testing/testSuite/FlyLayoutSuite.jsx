import { Button, HorizontalStack, Text, Box, Icon, TextField } from "@shopify/polaris"
import {
    CancelMajor,
    EditMinor,
    SearchMinor
} from '@shopify/polaris-icons';
import { useEffect, useMemo, useState } from "react";
import TestSuiteRow from "./TestSuiteRow";
import FlyLayout from "../../../components/layouts/FlyLayout";
import transform from "./transform";
import api from "../api";
import func from "../../../../../util/func";
import { debounce, set } from "lodash";

function FlyLayoutSuite(props) {
    const { show, setShow, selectedTestSuite, fetchTableData, createNewMode, setCreateNewMode } = props;
    const [testSuiteName, setTestSuiteName] = useState("");
    const [testSearchValue, setTestSearchValue] = useState("");
    const [categories, setCategories] = useState([]);
    const [filteredCategories, setFilteredCategories] = useState([]);
    const [isEditMode, setIsEditMode] = useState(false);

    const handleExit = () => {
        setShow(false);
        setTestSearchValue("");
        setIsEditMode(false);
        if(createNewMode===true) setCreateNewMode(false);
    }


    const handleTestSuiteSave = async () => {
        if (!testSuiteName || testSuiteName.trim().length === 0) {
            func.setToast(true, true, "Test Suite Name cannot be empty");
            return;
        }
        const selectedTestSuiteTests = [];
        const updatedCategories = [...categories];
        updatedCategories.forEach(element => {
            element.tests.forEach(test => {
                if (test.selected === true) {
                    selectedTestSuiteTests.push(test.value);
                }
            });

        });


        let hasChanged = false;
        if (testSuiteName !== selectedTestSuite?.name) hasChanged = true;
        if (selectedTestSuite?.Tests && !func.deepArrayComparison(selectedTestSuiteTests, selectedTestSuite?.tests)) {
            hasChanged = true;
        }



        try {
            let response;
            if (selectedTestSuite && hasChanged && !selectedTestSuite.isAutoGenerated) {
                response = await api.modifyTestSuite(selectedTestSuite.id, testSuiteName, selectedTestSuiteTests);
                func.setToast(true, false, "Test suite has been updated successfully.");
            } else {
                let name = selectedTestSuite?.isAutoGenerated? `${testSuiteName} Custom ${Date.now()}` : testSuiteName;
                response = await api.createNewTestSuite(name, selectedTestSuiteTests);
                func.setToast(true, false, "Test suite has been created successfully.");
            }
        } catch (error) {
            func.setToast(true, true, "An error occurred while saving the test suite.");
        }

        fetchTableData();
        handleExit();
    }


    const updateTestSuite = async () => {
        if (!selectedTestSuite?.tests) {
            setCategories([]);
            setTestSuiteName("");
            return;
        }

        const subCategoryMap = await transform.getSubCategoryMap();
        const selectedTestSuiteTestsSet = new Set(selectedTestSuite.tests);

        // Updates the test suite categories and name based on the selected test suite.
        const testSuiteSubCategoryMap = Object.entries(subCategoryMap).map(([_, tests]) => {
            const filteredTests = tests.filter(test => selectedTestSuiteTestsSet.has(test.value));
            if (filteredTests.length === 0) return null;

            return {
                tests: filteredTests,
                displayName: tests[0]?.categoryName || "",
                selected: false
            };
        }).filter(Boolean);

        setCategories(testSuiteSubCategoryMap);
        setTestSuiteName(selectedTestSuite.testSuiteName || "");
    };

    
    useEffect(() => {
        updateTestSuite();
    }, [selectedTestSuite]);

    useEffect(() => {
        if(createNewMode === true) {
            setIsEditMode(true);
        }
        else setIsEditMode(false);
    }, [createNewMode]);


    const filteredList = (value) =>{
        // this is only to make the row open when search is done
        if (value.length > 0) {
            setCategories((prev) => {
                const updatedCategories = [...prev];
                updatedCategories.forEach(category => {
                    if (category.tests.some((test) => test.label.toLowerCase().includes(value.toLowerCase()))) {
                        category.selected = true;
                    }
                }
                );
                return updatedCategories;
            });
        }
        else {
            setCategories((prev) => {
                const updatedCategories = [...prev];
                updatedCategories.forEach(category => {
                    category.selected = false;
                }
                );
                return updatedCategories;
            });
        }
    }

    useEffect(() => {
        let deepCopy = [];
        if (categories && Array.isArray(categories)) {
            deepCopy = JSON.parse(JSON.stringify(categories));
        }
        let updatedCategories = [...deepCopy];
        updatedCategories = updatedCategories.filter(category => {
            const tests = category.tests.filter(test =>
                test.label.toLowerCase().includes(testSearchValue.toLowerCase())
            );
            if(tests.length > 0){
                category.tests = tests;
                return true;
            }
            return false;
        });
        setFilteredCategories(updatedCategories);
    }, [categories]);


    async function handleSwitchMode() {
        if (!isEditMode) {
            updateTestSuite();
            return;
        }

        const subCategoryMap = await transform.getSubCategoryMap();
        const testSuiteSubCategoryMap = Object.values(subCategoryMap).map(tests => ({
            tests,
            displayName: tests[0]?.categoryName || "",
            selected: false
        }));

        if (selectedTestSuite?.tests?.length) {
            const selectedTestSet = new Set(selectedTestSuite.tests);
            testSuiteSubCategoryMap.forEach(category => {
                category.tests.forEach(test => {
                    test.selected = selectedTestSet.has(test.value);
                });
            });
        }

        setCategories(testSuiteSubCategoryMap);
    }

    useEffect(() => {
        handleSwitchMode();
    }, [isEditMode]);


    function checkExpand() {
        return filteredCategories.some(category => !category.selected);
    }

    const countSearchResults = () => {
        let count = 0;
        filteredCategories.forEach(category => { count += category.tests.length });
        return count;
    }

    const debouncedSearch = useMemo(() => debounce(filteredList, 500), []);

    useEffect(() => {
        return () => debouncedSearch.cancel();
    }, []);
    

    const handleSearchChange = (val) => {
        setTestSearchValue(val); 
        debouncedSearch(val); 
    };

    const headingComponents = (
        <Box borderColor="border-subdued" borderBlockStartWidth="1" borderBlockEndWidth="1" background="bg-subdued" padding={4}>
            <HorizontalStack align="space-between">
                <div style={{ width: "40%" }}>
                    <TextField maxLength={64} showCharacterCount disabled={!isEditMode} value={testSuiteName} onChange={(val) => setTestSuiteName(val)} label="Test Suite Name" placeholder="Test Suite Name" />
                </div>
                <div style={{ width: "58%", paddingTop: "1.5rem" }}>
                    <TextField value={testSearchValue} onChange={(val) => { handleSearchChange(val)}} prefix={<Icon source={SearchMinor} />} placeholder="Search" />
                </div>
            </HorizontalStack>
        </Box>
    )

    function extendAllHandler() {
        setCategories(prev => {
            return prev.map(category => ({ ...category, selected: true }));
        });
    }

    function collapseAllHandler() {
        setCategories(prev => {
            return prev.map(category => ({ ...category, selected: false }));
        });
    }

    function totalSelectedTestsCount() {
        return filteredCategories.reduce((count, category) => count + category.tests.length, 0);
    }

    function switchMode() {
        setIsEditMode(!isEditMode);
    }

    function countSelectedTest(){
        let count = 0;
        categories.forEach(category => {
            category?.tests?.forEach(test => {
                if(test.selected){
                    count++;
                }
            });
        });
        return count>1 ? `${count} tests` : `${count} test`;
    }

    function countSelectedCategories(){
        let count = 0;
        categories.forEach(category => {
            if(category?.tests?.some(test => test.selected)) count++;
        });
        return count>1 ? `${count} categories` : `${count} category`;
    }

    const listComponents = (
        <div style={{ margin: "20px", borderRadius: "0.5rem", boxShadow: " 0px 0px 5px 0px #0000000D, 0px 1px 2px 0px #00000026" }}>
            <Box borderRadius="2" borderColor="border-subdued" >
                <Box borderColor="border-subdued" paddingBlockEnd={3} paddingBlockStart={3} paddingInlineStart={5} paddingInlineEnd={5}>
                    <HorizontalStack align="space-between">
                        <HorizontalStack align="start">
                            <Text fontWeight="semibold" as="h3">{testSearchValue.length > 0 ? `Showing ${countSearchResults()} result` : !isEditMode? `${filteredCategories.length} ${filteredCategories.length > 1 ? 'categories' : 'category'} & ${totalSelectedTestsCount()} tests` :`${countSelectedTest()} from ${countSelectedCategories()} selected`}</Text>
                        </HorizontalStack>
                        {testSearchValue.trim().length === 0 ? <Button onClick={() => { checkExpand() ? extendAllHandler() : collapseAllHandler() }} plain><Text>{checkExpand() ? "Expand all" : "Collapse all"}</Text></Button> : <></>}
                    </HorizontalStack>
                </Box>
                {filteredCategories.length > 0 && filteredCategories.map((category, index) => {
                    return (
                        <TestSuiteRow filteredCategories={filteredCategories} categories={categories} isEditMode={isEditMode} isLast={index === filteredCategories.length - 1} key={index} category={category} setCategories={setCategories} setFilteredCategories={setFilteredCategories} />
                    )
                })}
            </Box>
        </div>
    );

    const footer = isEditMode == true? (
        <div style={{ position: "fixed", bottom: "0px", opacity: "1", width: "100%", background: "white" }}>
            <Box borderColor="border-subdued" borderBlockStartWidth="1" padding={"4"} >
                <HorizontalStack align="space-between">
                    <Button primary onClick={() => {handleTestSuiteSave()}}>Save</Button>
                </HorizontalStack>
            </Box>
        </div>
    ):null;

    const components = [headingComponents, listComponents,footer].filter(Boolean);

    const titleComp = (
        <div style={{width:"96%", display: "flex", justifyContent: "space-between"}}>
            <Text variant="headingMd">
                Test Suite
            </Text>
            {selectedTestSuite && (
                <Button icon={EditMinor} onClick={switchMode} plain></Button>
            )}            
        </div>
    )



    return (
        <FlyLayout
            titleComp={titleComp}
            show={show}
            setShow={setShow}
            components={components}
            handleClose={handleExit}
            loading={false}
            showDivider={false}
            newComp={true}
            isHandleClose={true}
            switchMode={switchMode}
            variant={"testSuiteFlyout"}>
        </FlyLayout>
    )
}


export default FlyLayoutSuite;