import { Badge, Box, Link } from "@shopify/polaris"
import func from "@/util/func"
import ShowListInBadge from "@/apps/dashboard/components/shared/ShowListInBadge"

const reportTransform = {
    createVulnerableAPIsSeverity: (vulnerableTestingRunResults) => {
        const countMap = {
            CRITICAL: 0,
            HIGH: 0,
            MEDIUM: 0,
            LOW: 0,
        }

        vulnerableTestingRunResults.forEach(item => {
            const confidence = item.testResults.filter((result) => {
              return result.vulnerable
            }).map((result) => result.confidence)[0]
            countMap[confidence]++
        })

        const result = {
            "Critical": {
                "text": countMap.CRITICAL || 0,
                "color": func.getHexColorForSeverity("CRITICAL"),
                "filterKey": "Critical"
            },
            "High": {
                "text": countMap.HIGH || 0,
                "color": func.getHexColorForSeverity("HIGH"),
                "filterKey": "High"
            },
            "Medium": {
                "text": countMap.MEDIUM || 0,
                "color": func.getHexColorForSeverity("MEDIUM"),
                "filterKey": "Medium"
            },
            "Low": {
                "text": countMap.LOW || 0,
                "color": func.getHexColorForSeverity("LOW"),
                "filterKey": "Low"
            }
        }
        return result
    },

    getTotalUniqueApis: (vulnerableTestingRunResults) => {
        const uniqueApis = new Set()
        vulnerableTestingRunResults.forEach(item => {
            const endpointKey = `${item.apiInfoKey.apiCollectionId}-${item.apiInfoKey.method}-${item.apiInfoKey.url}`
            uniqueApis.add(endpointKey)
        })

        return uniqueApis.size
    },

    createVulnerabilityMap: (testingRunResults, categoryMap, subCategoryMap) => {
        let result = {}
        let categoryVsIssuesMap = {}
        let categoryVsApisCountMap = {}
        let issueVsVulMap = {}
        let aktoFindingsTableData = []
        let aktoRecommendationsData = []
        let high = 0
        let medium = 0
        let low = 0
        let totalIssuesCount = 0
        testingRunResults?.length > 0 && testingRunResults.forEach((testingRun) => {
            let testSubtype = testingRun?.testSubType
            let testInfo = subCategoryMap?.[testSubtype]

            if (!testInfo) {
                return
            }
            let severity = testInfo?.superCategory?.severity?._name
            let severityIndex = 0;
            switch (severity) {
                case 'HIGH':
                    ++high
                    severityIndex = 2
                    break;
                case 'MEDIUM':
                    ++medium
                    severityIndex = 1
                    break;
                case 'LOW':
                    ++low
                    severityIndex = 0
                    break;
                default:
                    break;
            }

            let vulnerabilities = issueVsVulMap[testSubtype]
            if (vulnerabilities === undefined) {
                vulnerabilities = JSON.parse(JSON.stringify(testInfo))
            }
            let vulnerableTestingRunResults = vulnerabilities["vulnerableTestingRunResults"]
            if (vulnerableTestingRunResults === undefined) {
                vulnerableTestingRunResults = []
            }
            vulnerableTestingRunResults.push(testingRun)
            vulnerabilities['vulnerableTestingRunResults'] = vulnerableTestingRunResults
            vulnerabilities['severityIndex'] = severityIndex
            issueVsVulMap[testSubtype] = vulnerabilities
        })
        result = {
            ...result,
            severitiesCount: { HIGH: high, MEDIUM: medium, LOW: low }
        }
        let severityMapForIssueCategory = {}
        for (const [testSubType, issue] of Object.entries(issueVsVulMap)) {
            const categoryName = issue.superCategory.name
            const severity = issue?.superCategory?.severity?._name

            if (!categoryName) {
                continue
            }

            let issuesList
            if (!categoryVsIssuesMap.hasOwnProperty(categoryName)) {
                issuesList = []
                categoryVsIssuesMap[categoryName] = issuesList
            } else {
                issuesList = categoryVsIssuesMap[categoryName]
            }

            issuesList.push(issue)

            let apisCount = 0
            if (!categoryVsApisCountMap.hasOwnProperty(categoryName)) {
                categoryVsApisCountMap[categoryName] = 0
            } else {
                apisCount = categoryVsApisCountMap[categoryName]
            }

            if(severityMapForIssueCategory.hasOwnProperty(categoryName)){
                let initialCount = severityMapForIssueCategory[categoryName][severity] || 0
                severityMapForIssueCategory[categoryName][severity] = initialCount + issue?.vulnerableTestingRunResults?.length 
            }else{
                severityMapForIssueCategory[categoryName] = {}
                severityMapForIssueCategory[categoryName][severity] = issue?.vulnerableTestingRunResults?.length 
            }

            apisCount += issue.vulnerableTestingRunResults.length
            categoryVsApisCountMap[categoryName] = apisCount

            //Add to akto recommendation
            if (issue.hasOwnProperty("remediation")) {
                aktoRecommendationsData.push({
                    title: issue.testName,
                    content:  issue.remediation
                })
            }
        }
        let totalTemplates = 0
        let graphArr = []

        const sortedCategories = Object.keys(categoryVsIssuesMap)
        .map(categoryName => ({
            categoryName,
            issueCount: categoryVsIssuesMap[categoryName].length
        }))
        .sort((a, b) => b.issueCount - a.issueCount)

        sortedCategories.slice(0, 5).forEach((categoryData, index) => {
            const { categoryName } = categoryData
            graphArr.push({
                text: categoryMap[categoryName]?.displayName,
                value: categoryVsApisCountMap[categoryName],
                color: '#B6B0FE'
            })
        })

        graphArr.sort((a, b) => b.value - a.value)

        let issueSno = 1
        const severityLevels = func.getAktoSeverities().reverse()
        Object.keys(categoryVsIssuesMap).forEach((categoryName, index) => {
            const issuesArr = categoryVsIssuesMap[categoryName]
            totalTemplates += issuesArr.length
            issuesArr.forEach((issue, issueIndex) => {
                const severity = func.getRunResultSeverity(issue.vulnerableTestingRunResults[0], subCategoryMap)
                const severityIndex = severityLevels.indexOf(severity)
                totalIssuesCount += issue.vulnerableTestingRunResults.length
                aktoFindingsTableData.push({
                    key: issueSno,
                    sno: issueSno++,
                    issueNameComp: <Box><Link onClick={(e) => e.stopPropagation()} url={`#${issue.testName}`} removeUnderline><p style={{whiteSpace: 'normal'}}>{issue.testName}</p></Link></Box>,
                    issueName: issue.testName,
                    issueDescriptionComp: <Box><p style={{whiteSpace: 'normal'}}>{(issue.issueDescription.replace(/^"|"$/g, ''))}</p></Box>,
                    issueDescription: issue.issueDescription,
                    apisAffected: issue.vulnerableTestingRunResults.length,
                    issueCategory: issue.superCategory.displayName,
                    issueCategoryComp: <Box><p style={{whiteSpace: 'normal'}}>{issue.superCategory.displayName}</p></Box>,
                    issueImpactComp: <div className={`badge-wrapper-${severity}`}>
                                        <Badge size="small" key={issueIndex+'impact'}>{func.toSentenceCase(severity)}</Badge>
                                    </div>,
                    issueImpact: severityIndex,
                })
            })
        })

        const AKTO_RECOMMENDATIONS_LIMIT = 10
        if (aktoRecommendationsData.length > AKTO_RECOMMENDATIONS_LIMIT) {
            aktoRecommendationsData = aktoRecommendationsData.slice(0, AKTO_RECOMMENDATIONS_LIMIT)
        }

        aktoFindingsTableData.sort((a, b) => b.issueImpact - a.issueImpact)
        aktoFindingsTableData.forEach((item, index) => {
            item.sno = index + 1
        })

        result = {
            ...result,
            totalApisTested: reportTransform.getTotalUniqueApis(testingRunResults) || 0,
            totalIssues: totalIssuesCount || 0,
            categoryMap: categoryMap,
            categoryVsIssuesMap: categoryVsIssuesMap,
            categoryVsApisCountMap: categoryVsApisCountMap,
            aktoFindingsTableData: aktoFindingsTableData,
            aktoRecommendations: aktoRecommendationsData,
            graphData: graphArr
        }

        return result
    },
    prepareReportTestConfigurationData: (testingRun, testingRunType, testRole, testingRunResultSummary) => {
        const initialReportTestConfigurationData = { general: [], testRole: [], advanced: [] }
        const reportTestConfigurationData = testingRun ? initialReportTestConfigurationData : {}

        if (testingRun) {
            // ------- General Configuration
            const general = reportTestConfigurationData.general
            let generalIdx = 0

            // testingRunType
            if (testingRunType) {
                general.push({
                    id: generalIdx,
                    heading: "Test type",
                    description: func.getRunTypeLabel(testingRunType, testingRun.periodInSeconds),
                })
                generalIdx += 1
            }

            // maxConcurrentRequests
            if (testingRun.maxConcurrentRequests) {
                general.push({
                    id: generalIdx,
                    heading: "Max concurrent requests",
                    description: testingRun.maxConcurrentRequests === -1 ? "Default" : testingRun.maxConcurrentRequests,
                })
                generalIdx += 1
            }

            // overriddenTestAppUrl
            if (testingRun.testingRunConfig?.overriddenTestAppUrl && testingRun.testingRunConfig?.overriddenTestAppUrl.length > 0) {
                general.push({
                    id: generalIdx,
                    heading: "Host used for testing",
                    description: testingRun.testingRunConfig.overriddenTestAppUrl,
                })
                generalIdx += 1
            }

            //startTime
            if (testingRunResultSummary && testingRunResultSummary.state === "COMPLETED") {
                const { startTimestamp, endTimestamp } = testingRunResultSummary

                general.push({
                    id: generalIdx,
                    heading: "Test started at",
                    description: `${func.epochToDateTime(startTimestamp)}`
                })
                generalIdx += 1

                general.push({
                    id: generalIdx,
                    heading: "Test completed at",
                    description: `${func.epochToDateTime(endTimestamp)}`
                })
                generalIdx += 1
            }

            // ------- Advanced Configuration
            const advanced = reportTestConfigurationData.advanced
            let advancedIdx = 0

            const configsAdvancedSettings = testingRun.testingRunConfig?.configsAdvancedSettings
            if (configsAdvancedSettings) {
                const operatorTypeOptions = {
                    "ADD_HEADER": { heading: "Add Header", status: "info" },
                    "ADD_BODY_PARAM": { heading: "Add Body Param", status: "info" },
                    "MODIFY_HEADER": { heading: "Modify Header", status: "warning" },
                    "MODIFY_BODY_PARAM": { heading: "Modify Body Param", status: "warning" },
                    "DELETE_HEADER": { heading: "Delete Header", status: "critical" },
                    "DELETE_BODY_PARAM": { heading: "Delete Body Param", status: "critical" }
                };

                configsAdvancedSettings.forEach((advancedSetting) => {
                    const formattedOperationsGroupList = advancedSetting.operationsGroupList.map(operation => {
                        return operation.value.length > 0 ? `${operation.key}=${operation.value}` : `${operation.key}`
                    })

                    advanced.push({
                        id: advancedIdx,
                        heading: operatorTypeOptions[advancedSetting.operatorType].heading,
                        component: (
                            <ShowListInBadge
                                itemsArr={formattedOperationsGroupList}
                                status={operatorTypeOptions[advancedSetting.operatorType].status}
                                useTooltip={true}
                                wrap={true}
                            />
                        ),
                    })
                    advancedIdx += 1     
                })
            }
        }

        if (testRole) {
            // ------- Test Role Configuration
            const testRoleData = reportTestConfigurationData.testRole
            let testRoleIdx = 0

            // Name
            testRoleData.push({
                id: testRoleIdx,
                heading: "Name",
                description: testRole.name,
            })
            testRoleIdx += 1

            const authWithCondList = testRole.authWithCondList
            authWithCondList.forEach((authWithCond, index) => {
                const formattedAuthWithCondList = []

                const authMechanismType = authWithCond.authMechanism.type
                formattedAuthWithCondList.push(`Type: ${authMechanismType}`)

                const headerKVPairs = authWithCond.headerKVPairs
                if (headerKVPairs && Object.keys(headerKVPairs).length > 0) {
                    const headerKey = Object.keys(headerKVPairs)[0]
                    const headerValue = headerKVPairs[headerKey]
                    formattedAuthWithCondList.push(`API header conditions: ${headerKey}=${headerValue}`)
                }

                testRoleData.push({
                    id: testRoleIdx,
                    heading: `Auth mechanism - ${index + 1}`,
                    component: (
                        <ShowListInBadge
                            itemsArr={formattedAuthWithCondList}
                            status={"info"}
                            useTooltip={true}
                            wrap={true}
                        />
                    ),
                })
                testRoleIdx += 1
            })
        }

        return reportTestConfigurationData
    }
}

export default reportTransform