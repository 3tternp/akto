package com.akto.action.gpt;

import com.akto.action.UserAction;
import com.akto.action.gpt.cache.VulnerabilityAnalysisCache;
import com.akto.action.gpt.handlers.GptQuery;
import com.akto.action.gpt.handlers.QueryHandler;
import com.akto.action.gpt.handlers.QueryHandlerFactory;
import com.akto.dto.User;
import com.mongodb.BasicDBObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class VulnerabilityAnalysisAction extends UserAction {
    
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityAnalysisAction.class);
    public static final String USER_EMAIL = "user_email";
    
    private final VulnerabilityAnalysisCache cache = VulnerabilityAnalysisCache.getInstance();
    
    private String responseOutput;
    private BasicDBObject analysisResult;
    
    public String analyzeVulnerability() {
        try {
            User sUser = getSUser();
            
            // Parse the structured data from frontend
            BasicDBObject testData = parseTestData(responseOutput);
            
            // Extract test result ID for caching
            String testResultId = testData.getString("testResultId");
            
            // Extract test context for metadata
            String testCategory = "UNKNOWN";
            String testDescription = "";
            BasicDBObject testContext = (BasicDBObject) testData.get("testContext");
            if (testContext != null) {
                if (testContext.getString("category") != null) {
                    testCategory = testContext.getString("category");
                }
                if (testContext.getString("description") != null) {
                    testDescription = testContext.getString("description");
                }
            }
            
            // Check cache if test result ID is available
            String cacheKey = cache.generateCacheKey(testResultId, testData);
            if (cacheKey != null) {
                analysisResult = cache.get(cacheKey);
                if (analysisResult != null) {
                    return SUCCESS.toUpperCase();
                }
            }
            
            // Prepare metadata for the query handler with structured data
            BasicDBObject meta = new BasicDBObject();
            meta.put(USER_EMAIL, sUser.getLogin());
            meta.put("testData", testData);  // Pass parsed structured data
            meta.put("testCategory", testCategory);
            meta.put("testDescription", testDescription);
            
            // Get the appropriate query handler and execute
            GptQuery query = GptQuery.ANALYZE_VULNERABILITY;
            QueryHandler queryHandler = QueryHandlerFactory.getQueryHandler(query);
            analysisResult = queryHandler.handleQuery(meta);
            
            // Cache the result if we have a valid cache key
            if (analysisResult != null && cacheKey != null) {
                cache.put(cacheKey, analysisResult);
            }
            
            if (analysisResult == null) {
                throw new Exception("Received empty response from vulnerability analysis");
            }
            
            return SUCCESS.toUpperCase();
        } catch (Exception e) {
            logger.error("Error analyzing vulnerability", e);
            addActionError(e.getMessage());
            return ERROR.toUpperCase();
        }
    }
    
    private BasicDBObject parseTestData(String responseOutput) {
        try {
            return BasicDBObject.parse(responseOutput);
        } catch (Exception e) {
            logger.warn("Failed to parse structured test data, using fallback", e);
            // Fallback to old format if parsing fails
            BasicDBObject fallback = new BasicDBObject();
            fallback.put("response", new BasicDBObject("body", responseOutput));
            return fallback;
        }
    }
    
    public String getResponseOutput() {
        return responseOutput;
    }
    
    public void setResponseOutput(String responseOutput) {
        this.responseOutput = responseOutput;
    }
    
    public BasicDBObject getAnalysisResult() {
        return analysisResult;
    }
    
    public void setAnalysisResult(BasicDBObject analysisResult) {
        this.analysisResult = analysisResult;
    }
}