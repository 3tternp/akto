package com.akto.action.gpt.handlers;

import com.akto.action.gpt.GptAction;
import com.akto.action.gpt.result_fetchers.ResultFetcherStrategy;
import com.mongodb.BasicDBObject;
import com.mongodb.BasicDBList;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class AnalyzeVulnerability implements QueryHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(AnalyzeVulnerability.class);
    private final ResultFetcherStrategy<BasicDBObject> resultFetcherStrategy;
    
    public AnalyzeVulnerability(ResultFetcherStrategy<BasicDBObject> resultFetcherStrategy) {
        this.resultFetcherStrategy = resultFetcherStrategy;
    }
    
    @Override
    public BasicDBObject handleQuery(BasicDBObject meta) throws Exception {
        BasicDBObject testData = (BasicDBObject) meta.get("testData");
        String testCategory = meta.getString("testCategory");
        
        // If testData is not provided, this is an error
        if (testData == null) {
            throw new Exception("No test data provided for vulnerability analysis");
        }
        
        BasicDBObject request = new BasicDBObject();
        request.put("query_type", GptQuery.ANALYZE_VULNERABILITY.getName());
        request.put("test_data", testData);  // Pass structured data instead of raw response
        request.put(GptAction.USER_EMAIL, meta.getString(GptAction.USER_EMAIL));
        
        // Create the prompt for LLM using the structured data
        String prompt = buildPrompt(testData);
        request.put("prompt", prompt);
        
        logger.debug("Analyzing response for {} vulnerabilities", testCategory);
        
        // Call LLM to analyze the response
        BasicDBObject llmResponse = this.resultFetcherStrategy.fetchResult(request);
        
        // Process and format the LLM response
        BasicDBObject result = processLLMResponse(llmResponse, testData);

        return result;
    }
    
    private String buildPrompt(BasicDBObject testData) {
        StringBuilder prompt = new StringBuilder();
        
        // Extract structured data
        BasicDBObject testContext = (BasicDBObject) testData.get("testContext");
        BasicDBObject request = (BasicDBObject) testData.get("request");
        BasicDBObject response = (BasicDBObject) testData.get("response");
        
        // Get test category from the structured data
        String testCategory = "UNKNOWN";
        if (testContext != null && testContext.getString("category") != null) {
            testCategory = testContext.getString("category");
        }
        
        // Use testCategory as the primary vulnerability type
        prompt.append("Analyze the following HTTP request/response for ").append(testCategory).append(" vulnerabilities.\n\n");
        
        // Add test context information
        if (testContext != null) {
            prompt.append("Test Context:\n");
            if (testContext.getString("category") != null) {
                prompt.append("- Category: ").append(testContext.getString("category")).append("\n");
            }
            if (testContext.getString("description") != null) {
                prompt.append("- Description: ").append(testContext.getString("description")).append("\n");
            }
            if (testContext.getString("severity") != null) {
                prompt.append("- Severity: ").append(testContext.getString("severity")).append("\n");
            }
            if (testContext.get("cwe") != null) {
                prompt.append("- CWE IDs: ").append(testContext.get("cwe")).append("\n");
            }
            prompt.append("\n");
        }
        
        // Add minimal request context
        if (request != null) {
            prompt.append("Request Context:\n");
            if (request.getString("method") != null) {
                prompt.append("- Method: ").append(request.getString("method")).append("\n");
            }
            if (request.getString("url") != null) {
                prompt.append("- URL: ").append(request.getString("url")).append("\n");
            }
            if (request.getString("contentType") != null) {
                prompt.append("- Content-Type: ").append(request.getString("contentType")).append("\n");
            }
            if (request.getString("authorization") != null) {
                prompt.append("- Authorization: ").append(request.getString("authorization")).append("\n");
            }
            if (request.getString("userAgent") != null) {
                prompt.append("- User-Agent: ").append(request.getString("userAgent")).append("\n");
            }
            if (request.getString("xForwardedFor") != null) {
                prompt.append("- X-Forwarded-For: ").append(request.getString("xForwardedFor")).append("\n");
            }
            if (request.getString("origin") != null) {
                prompt.append("- Origin: ").append(request.getString("origin")).append("\n");
            }
            if (request.getString("referer") != null) {
                prompt.append("- Referer: ").append(request.getString("referer")).append("\n");
            }
            prompt.append("\n");
        }
        
        // Add response data (primary analysis target)
        if (response != null) {
            prompt.append("Response Data to analyze:\n");
            if (response.getInt("statusCode") > 0) {
                prompt.append("- Status Code: ").append(response.getInt("statusCode")).append("\n");
            }
            if (response.get("headers") != null) {
                prompt.append("- Headers: ").append(response.get("headers")).append("\n");
            }
            if (response.getString("body") != null) {
                prompt.append("- Body: ").append(response.getString("body")).append("\n");
            }
            prompt.append("\n");
        }
        
        prompt.append("Instructions:\n");
        prompt.append("1. Focus on the response body and headers for ").append(testCategory).append(" vulnerability indicators\n");
        prompt.append("2. For each vulnerability found, provide the start and end position in the response body (character index)\n");
        prompt.append("3. Consider the request context (method, URL, content-type) when analyzing the response\n");
        prompt.append("4. Return the analysis in JSON format with structure:\n");
        prompt.append("{\n");
        prompt.append("  \"vulnerableSegments\": [\n");
        prompt.append("    {\n");
        prompt.append("      \"start\": number,\n");
        prompt.append("      \"end\": number,\n");
        prompt.append("      \"phrase\": \"exact vulnerable substring\"\n");
        prompt.append("    }\n");
        prompt.append("  ]\n");
        prompt.append("}\n\n");
        
        return prompt.toString();
    }
    
    private BasicDBObject processLLMResponse(BasicDBObject llmResponse, BasicDBObject testData) {
        BasicDBObject result = new BasicDBObject();
        
        try {
            // Parse the LLM response - it should contain the vulnerability analysis
            if (llmResponse != null && llmResponse.containsField("response")) {
                String llmResponseStr = llmResponse.getString("response");
                
                // Try to parse the JSON response from LLM
                try {
                    BasicDBObject parsedResponse = BasicDBObject.parse(llmResponseStr);
                    
                    // Only return vulnerable segments - vulnerabilityType and isVulnerable are already known
                    BasicDBList segments = (BasicDBList) parsedResponse.get("vulnerableSegments");
                    if (segments == null) {
                        segments = new BasicDBList();
                    }
                    
                    result.put("vulnerableSegments", segments);
                    
                } catch (Exception e) {
                    logger.error("Failed to parse LLM JSON response, using fallback", e);
                    // Fallback: create a simple response if JSON parsing fails
                    result.put("vulnerableSegments", new BasicDBList());
                }
            } else {
                // No response from LLM
                result.put("vulnerableSegments", new BasicDBList());
            }
            
        } catch (Exception e) {
            logger.error("Error processing LLM response", e);
            result.put("vulnerableSegments", new BasicDBList());
        }
        
        return result;
    }
}